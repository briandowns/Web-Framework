import Base64;
import Datetime;
import Hashlib;
import HTTP;
import JSON;
import Socket;
import Sqlite;
import System;


class DB {
    init(path) {
        this.connection = Sqlite.connect(path).unwrap();
    }

    execute(query, values) {
        var result = this.connection.execute(query, values);

        if (not result.success()) {
            print(result.unwrapError());
            System.exit(1);
        }

        return result.unwrap();
    }

    close() {
        this.connection.close();
    }
}

class Request {
    init(data) {
        const rawData = data.split("\r\n\r\n");
        const headers = rawData[0].split("\r\n");
        const body = rawData[1];
        
        const routeData = headers[0].split(" ");

        this.verb = routeData[0];
        
        this.headers = {};
        this.body = {};

        this.parseUrl(routeData[1]);
        this.parseHeaders(headers);

        if (this.headers.get("Content-Type", "") == "application/x-www-form-urlencoded" and body != "") {
            this.parseBody(body);
        }
    }

    parseUrl(route) {
        this.query = {};

        const url = route.split("?");
        this.route = url[0];

        // No query parameters
        if (url.len() == 1) {
            return;
        }

        const parameters = url[1].split("&");

        parameters.forEach(def (parameter) => {
            const variable = parameter.split("=");

            if (variable.len() == 2) {
                this.query[variable[0]] = variable[1];
            } else {
                this.query[variable[0]] = nil;
            }
        });
    }

    parseHeaders(headers) {
        for (var i = 1; i < headers.len(); i += 1) {
            const headerData = headers[i].split(":");
            this.headers[headerData[0]] = headerData[1].strip();
        }
    }

    parseBody(body) {
        body.split("&").forEach(def (element) => {
            const variable = element.split("=");
            this.body[variable[0]] = variable[1];
        });
    }
}

abstract class BaseResponse {
    var statusCodes = {
        // 2xx
        HTTP.STATUS_CODE_OK: HTTP.STATUS_MESSAGE_OK,
        HTTP.STATUS_CODE_CREATED: HTTP.STATUS_MESSAGE_CREATED,
        // 3xx
        301: "301 Moved Permanently",
        // 4xx
        400: "400 Bad Request",
        401: "401 Unauthorized",
        403: "403 Forbidden",
        404: "404 Not Found",
        // 5xx
        500: "500 Internal Server Error"
    };

    init() {
        this.headers = {
            "Server": "Dictu-Server",
            "Connection": "close",
            "Content-Type": "text/html"
        };
    }

    addHeader(key, value) {
        this.headers[key] = value;
    }

    setCookie(value, httpOnly=true, secure=false) {
        this.headers["Set-Cookie"] = "{}{}{}".format(
            value,
            httpOnly ? "; HttpOnly" : "",
            secure ? "; Secure" : ""
        );
    }

    send(client) {
        var responseHeaders = "HTTP/1.1 {}\r\nDate: {}\r\n".format(this.status, Datetime.strftime("%a, %d %b %Y %H:%M:%S"));
        
        this.headers.keys().forEach(def (key) => {
            responseHeaders += "{}: {}\r\n".format(key, this.headers[key]);
        });

        client.write(responseHeaders + "\r\n" + this.content);
    }
}

class Response < BaseResponse {
    init(content, status=HTTP.STATUS_CODE_OK) {
        super.init();

        this.content = content;
        this.status = this.statusCodes[status];

        this.headers["Content-Length"] = content.len();
    }
}

class JsonResponse < BaseResponse {
    init(content, status=200) {
        super.init();

        this.content = JSON.stringify(content).unwrap();
        this.status = this.statusCodes[status];

        this.headers["Content-Length"] = this.content.len();
        this.headers["Content-Type"] = "application/json";
    }
}

class ErrorResponse < BaseResponse {
    init(content="", status=HTTP.STATUS_CODE_INTERNAL_SERVER_ERROR) {
        super.init();

        this.content = content;
        this.status = this.statusCodes[status];
        this.headers["Content-Length"] = content.len();
    }
}

abstract class BaseSessionHandler {
    abstract save(request)
    abstract load(request)
}

class Server {
    const HTTP_DELIMITER = "\r\n\r\n";

    // TODO: Investigate why callback can't be private
    init(var callback, private host="127.0.0.1", private port=8080) {
        this.socket = nil;
    }

    start() {
        const socket = Socket.create(Socket.AF_INET, Socket.SOCK_STREAM);
        if (not socket.success()) {
            return socket;
        }

        this.socket = socket.unwrap();
        this.socket.setsockopt(Socket.SOL_SOCKET, Socket.SO_REUSEADDR);
        
        if (not this.socket.bind(this.host, this.port).success()) {
            return Error("failed to bind socket");
        }

        this.listen();
    }

    listen() {
        const result = this.socket.listen();
        if (not result.success()) {
            print(result.unwrapError());
            System.exit(1);
        }
        
        while {
            const connection = this.socket.accept();
            if (not connection.success()) {
                print(connection.unwrapError());
                System.exit(1);
            }

            const [client, address] = connection.unwrap();
            this.handleClient(client, address);
        }
    }

    handleClient(client, address) {
        const data = this.getData(client);
        if (data != '') {
            this.callback(client, address, data);
        }
        client.close();
    }

    getData(client, size=2048) {
        var buffer = client.recv(size);

        if (not buffer.success()) {
            print(buffer.unwrapError());
            System.exit(1);
        }

        buffer = buffer.unwrap();

        if (buffer.len() != size) {
            return buffer;
        }

        while {
            const data = client.recv(size);

            if (not data.success()) {
                print(data.unwrapError());
                System.exit(1);
            }

            buffer += data.unwrap();

            if (buffer.contains(this.HTTP_DELIMITER)) {
                break;
            }
        }

        return buffer;
    }
}

class SessionHandler < BaseSessionHandler {
    init(app) {
        this.key = app.key;

        app.middleware.insert(this.load, 0);
    }

    load(request) {
        const cookie = request.headers.get("Cookie", false);
        request.session = {};
        request.sessionCopy = request.session.copy();

        if (cookie and cookie.startsWith("session=")) {
            const payload = cookie[8:];
            const [session, base64Hmac] = payload.split(".");

            const decodedSession = Base64.decode(session);
            const sessionHmac = Hashlib.hmac(this.key, decodedSession, true);
            
            // Ensure the cookies signature is correct
            if (Hashlib.verify(Base64.encode(sessionHmac), base64Hmac)) {
                const parsedSession = JSON.parse(decodedSession);
                if (parsedSession.success()) {
                    request.session = parsedSession.unwrap();
                } else {
                    request.session = {};
                }
            }
        }
    }

    save(session, sessionCopy, response) {
        // Session updated. Update cookie
        if (session != sessionCopy) {
            const stringSessionResult = JSON.stringify(session);

            if (stringSessionResult.success()) {
                const stringSession = stringSessionResult.unwrap();
                const base64Session = Base64.encode(stringSession);
                const base64Hmac = Base64.encode(Hashlib.hmac(this.key, stringSession, true));

                response.setCookie("session={}.{}".format(base64Session, base64Hmac));
            }
        }
    }
}

class Wanbli {
    init(host="127.0.0.1", port=8080, private debug=false) {
        this.server = Server(this.response, host, port);

        this.routes = {
            HTTP.METHOD_GET: {},
            HTTP.METHOD_POST: {},
            HTTP.METHOD_PUT: {},
            HTTP.METHOD_DELETE: {},
            HTTP.METHOD_HEAD: {},
            HTTP.METHOD_PATCH: {}
        };

        this.middleware = [];
        this.sessionHandler = nil;
    }

    start() {
        this.server.start();
    }

    response(client, address, data) {
        const request = Request(data);
        if (this.debug) {
            print("{} [{}] {} {}".format(
                address,
                Datetime.strftime("%a, %d %b %Y %H:%M:%S"),
                request.verb,
                request.route
            ));
        }

        var response = this.handleMiddleware(request);
        if (response != nil) {
            response.send(client);
            return;
        }

        response = this.dispatch(request);

        if (this.sessionHandler != nil) {
            this.sessionHandler.save(request.session, request.sessionCopy, response);
        }

        response.send(client);
    }

    dispatch(request) {
        if (this.routes.exists(request.verb)) {
            if (this.routes[request.verb].exists(request.route)) {
                var response = this.routes[request.verb][request.route](request);

                if (type(response) == "string") {
                    response = Response(response);
                } else if (["list", "number", "nil", "bool", "dict"].contains(type(response))) {
                    response = JsonResponse(response);
                }

                return response;
            }
        }

        return this.notFoundHandler(request);
    }

    notFoundHandler(request) {
        return ErrorResponse(HTTP.STATUS_MESSAGE_NOT_FOUND, HTTP.STATUS_CODE_NOT_FOUND);
    }

    private handleMiddleware(request) {
        for (var i = 0; i < this.middleware.len(); i += 1) {
            const response = this.middleware[i](request);
            if (response != nil) {
                return response;
            }
        }
    }

    addSessionHandler(handler) {
        this.sessionHandler = handler;
    }

    define(callback) {
        this.middleware.push(callback);
    }

    defineRoute(verb, route, callback) {
        this.routes[verb][route] = callback;
    }

    addController(klass) {
        const classRef = klass._class;
        if (classRef.classAnnotations.len() == 0 or not classRef.classAnnotations.exists("Controller")) {
            return Error("'Controller' class annotation required");
        }

        print("Class: {}".format(classRef.classAnnotations));
        print("Method: {}".format(classRef.methodAnnotations));
        // if (classRef.methodAnnotations == nil) {
        //     return Error("method annotation(s) required for HTTP verb");
        // }

        // classRef.methodAnnotations.forEach(def(k, v) => {
        //     if (not v.exists("Path")) {
        //         annotationParseError = Error("no Path annotation found on '{}' method".format(k));
        //     }
        // });

        const path = classRef.classAnnotations.get("Controller");
        classRef.methods().forEach(def(m) => {
            switch (m) {
                case "get": {print(m);this.defineRoute(HTTP.METHOD_GET, path, klass.get);}
                case "post": this.defineRoute(HTTP.METHOD_POST, path, klass.post);
                case "delete": this.defineRoute(HTTP.METHOD_DELETE, path, klass.delete);
                case "put": this.defineRoute(HTTP.METHOD_PUT, path, klass.put);
                case "head": this.defineRoute(HTTP.METHOD_HEAD, path, klass.head);
                case "option": this.defineRoute(HTTP.METHOD_HEAD, path, klass.option);
            }
        });

        return Success(0);
    }
}